# 数学

## BSGS

- 用于计算方程 $ a^x = b (% p)$

```c_cpp
int BSGS(int a,int b,int p)
{
    map<int,int > hash;
    b %= p;
    int t = (int)sqrt(p) + 1;
    for(int j = 0; j < t; j ++){
        int val = 1ll * b * fpow(a,j,p) % p;
        hash[val] = j;
    }
    a = fpow(a,t,p);
    if(!a) return b == 0 ? 1 : -1;
    for(int i = 0; i <= t;++i){
        int val = fpow(a,i,p);
        int j = hash.find(val) == hash.end() ? -1 : hash[val];
        if(j >= 0 && i * t - j > 0) return i * t - j;
    }
    return -1;
}
```

## 扩展中国剩余定理

### 值在__int128以内

```c_cpp
typedef __int128 ll;
void exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b){
        x = 1;y = 0;
        return ;
    }
    exgcd(b,a % b,y,x);
    y -= a / b * x;
}
ll inv(ll a,ll p)
{
    ll x,y;
    exgcd(a,p,x,y);
    if(x < 0) x += p;
    return x;
}
ll ex_crt()
{
    bool flag = true;
    ll m1,m2,c1,c2,tmp;
    for(int i = 2;i <= n;++i){//m[i]为模,c[i]为余数
        m1 = m[i - 1];m2 = m[i];
        c1 = c[i - 1];c2 = c[i];
        tmp = gcd(m1,m2);
        if((c2 - c1) % tmp != 0) {
            flag = false;
            return -1;
        }
        m[i] = m1 / tmp * m2;
        c[i] = inv(m1 / tmp,m2 / tmp) * (c2 - c1) / tmp % (m2 / tmp) * m1 + c1;
        c[i] = (c[i] % m[i] + m[i]) % m[i];
    }
    return c[n];
}
```

### 值在__int128以外

```python
import sys 
def exgcd(a, b):
    if b == 0:
        return (a, 1, 0)
    q = a // b
    g, y, x = exgcd(b, a - q * b)
    y -= q * x
    return (g, x, y)

def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

N, lim = map(int, input().split())
M, ans = map(int, input().split())
f = 0
for i in range(0, N - 1):
    m, r = map(int, input().split())
    A = M
    B = m
    C = ((r - ans) % m)
    if (ans - r) % gcd(M, m) != 0:
        f = 1
    g, x, y = exgcd(A, B)
    x = (x * C // g) % (B // g)
    ans += x * M
    M *= B // g
    ans %= M

if ans < 0:
    ans += M
if f == 1:
    ans = -1
    print(ans)
else:
    print(ans)
# print ans
```

## 扩展卢卡斯

```c_cpp
ll n, m, p;
ll exgcd(ll a, ll b, ll &x, ll &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    ll res = exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * y;
    return res;
}

ll fpow(ll a, ll b, ll mod){
    ll res = 1;
    while(b){
        if(b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}

ll inv(ll a, ll p){
    ll x, y;
    exgcd(a, p, x, y);
    if(x + p > p) return x;
    return x + p;
}

inline ll crt(ll n, ll mod)
{
    return n * (p / mod) % p * inv(p / mod, mod) % p;
}

ll fac(ll n, ll p, ll k){        //k = p^x
       if(!n) return 1;
       ll ans = 1;
    for(int i = 2; i <= k;++i)
        if(i % p) ans = ans * i % k;
    ans = fpow(ans, n / k, k);
    for(int i = 2; i <= n % k;++i)
        if(i % p) ans = ans * i % k;
    return ans * fac(n / p, p, k) % k;
}

ll C(ll n, ll m, ll p, ll k){    //k = p^x
       if(n < m) return 0;
    ll a = fac(n,p,k), b = fac(m,p,k), c = fac(n - m,p,k);
    ll cnt = 0;
    for(ll i = p; i <= n; i *= p) cnt += n / i;
    for(ll i = p; i <= m; i *= p) cnt -= m / i;
    for(ll i = p; i <= n-m; i *= p) cnt -= (n - m) / i;
    return a*inv(b, k) % k * inv(c, k) % k * fpow(p, cnt, k) % k ;
}

ll ex_Lucas()
{
    ll t = p, ans =i;
            t /= i;
        }
        ans = (ans + crt(C(n, m, i, tmp), tmp))%p;
    }
    if(t > 1) ans = (ans + crt(C(n, m, t, t), t))%p;
    return ans%p;
}
```

## fft

- 多项式快速计算

```c_cpp
const double PI = acos(-1.0);
struct Complex{
    double x, y; // 实部和虚部 x+yi
    Complex(double _x = 0.0, double _y = 0.0) {
        x = _x;
        y = _y;
    }
    Complex operator-(const Complex &b) const {
        return Complex(x - b.x, y - b.y);
    }
    Complex operator+(const Complex &b) const {
        return Complex(x + b.x, y + b.y);
    }
    Complex operator*(const Complex &b) const {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
/*
* 进行 FFT 和 IFFT 前的反转变换。
* 位置 i 和 (i 二进制反转后位置)互换
* len 必须去 2 的幂
*/
void change(Complex y[], int len){
    for (int i = 1, j = len / 2,k;i < len - 1;++i){
        if (i < j)swap(y[i], y[j]);
        //交换互为小标反转的元素,i<j 保证交换一次
        //i 做正常的+1,j 左反转类型的+1,始终保持 i 和 j 是反转的
        k = len / 2;
        while(j >= k){
            j -= k;
            k >>= 1;
        }
        if (j < k) j += k;
    }
}
/*
* 做 FFT
* len 必须为 2^k 形式,
* on==1 时是 DFT,on==-1 时是 IDFT
*/
void fft(Complex y[], int len, int on) {
    change(y, len);
    for (int h = 2; h <= len; h <<= 1) {
        Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h));
        for (int j = 0; j < len; j += h) {
            Complex w(1, 0);
            for (int k = j; k < j + h / 2; k++) {
                Complex u = y[k];
                Complex t = w * y[k + h / 2];
                y[k] = u + t;
                y[k + h / 2] = u - t;
                w = w * wn;
            }
        }
    }
    if (on == -1)
        for (int i = 0; i < len; i++) y[i].x /= len;
}
```

use by indiewar
```cpp
using int64 = long long;

namespace fft {
    const int N = 1 << 21, M = 31768;
    struct Complex {
        double x , y;
        Complex () {x = y = 0;}
        Complex (double _x , double _y) {x = _x , y = _y;}
        Complex operator + (const Complex& r) const {
            return Complex(x + r.x , y + r.y);
        }
        Complex operator - (const Complex& r) const {
            return Complex(x - r.x , y - r.y);
        }
        Complex operator * (const double k) const {
            return Complex(x * k, y * k);
        }
        Complex operator / (const double k) const {
            return Complex(x / k, y / k);
        }
        Complex operator * (const Complex& r) const {
            return Complex(x * r.x - y * r.y , x * r.y + y * r.x);
        }
        int operator = (const int a) {
            *this = Complex(a , 0);
            return a;
        }
        Complex conj() const {
            return Complex(x, -y);
        }
    };
    const double pi = acos(-1.0);
    Complex w[N];
    int rev[N];
    void init(int L) {
        int n = 1 << L;
        for (int i = 0 ; i < n ; ++ i) {
            double ang = 2 * pi * i / n;
            w[i] = Complex(cos(ang) , sin(ang));
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (L - 1));
        }
    }
    void trans(Complex P[], int n, int oper) {
        for (int i = 0 ; i < n ; i ++) {
            if (i < rev[i]) {
                std::swap(P[i], P[rev[i]]);
            }
        }
        for (int d = 0; (1 << d) < n; d++) {
            int m = 1 << d, m2 = m * 2 , rm = n / m2;
            for (int i = 0; i < n; i += m2) {
                for (int j = 0; j < m; j++) {
                    Complex &P1 = P[i + j + m], &P2 = P[i + j];
                    Complex t = w[rm * j] * P1;
                    P1 = P2 - t;
                    P2 = P2 + t;
                }
            }
        }
        if (oper == -1) {
            for (int i = 0; i < n; ++i) {
                P[i] = P[i] / n;
            }
        }
    }
    Complex A[N] , B[N] , C1[N] , C2[N];
    std::vector<int64> conv(const std::vector<int> &a, const std::vector<int> &b) {
        int n = a.size(), m = b.size(), L = 0, s = 1;
        while (s <= n + m - 2) s <<= 1, ++L;
        init(L);
        for (int i = 0; i < s; ++i) {
            A[i] = i < n ? Complex(a[i], 0) : Complex();
            B[i] = i < m ? Complex(b[i], 0) : Complex();
        }
        trans(A, s, 1);
        trans(B, s, 1);
        for (int i = 0; i < s; ++i) {
            A[i] = A[i] * B[i];
        }
        for (int i = 0; i < s; ++i) {
            w[i] = w[i].conj();
        }
        trans(A, s, -1);
        std::vector<int64> res(n + m - 1);
        for (int i = 0; i < n + m - 1; ++i) {
            res[i] = (int64)(A[i].x + 0.5);
        }
        return res;
    }
    std::vector<int64> fast_conv(const std::vector<int> &a, const std::vector<int> &b) {
        int n = a.size(), m = b.size(), L = 0, s = 1;
        for (; s <= n + m - 2; s <<= 1, ++L);
        s >>= 1, --L;
        init(L);
        for (int i = 0; i < s; ++i) {
            A[i].x = (i << 1) < n ? a[i << 1] : 0;
            B[i].x = (i << 1) < m ? b[i << 1] : 0;
            A[i].y = (i << 1 | 1) < n ? a[i << 1 | 1] : 0;
            B[i].y = (i << 1 | 1) < m ? b[i << 1 | 1] : 0;
        }
        trans(A, s, 1); trans(B, s, 1);
        for (int i = 0; i < s; ++i) {
            int j = (s - i) & (s - 1);
            C1[i] = (Complex(4, 0) * (A[j] * B[j]).conj() - (A[j].conj() - A[i]) * (B[j].conj() - B[i]) * (w[i] + Complex(1, 0))) * Complex(0, 0.25);
        }
        std::reverse(w + 1, w + s);
        trans(C1, s, -1);
        std::vector<int64> res(n + m);
        for (int i = 0; i <= (n + m - 1) / 2; ++i) {
            res[i << 1] = int64(C1[i].y + 0.5);
            res[i << 1 | 1] = int64(C1[i].x + 0.5);
        }
        res.resize(n + m - 1);
        return res;
    }
    // arbitrary modulo convolution
    void conv(int a[], int b[], int n, int m, int mod, int res[]) {
        int s = 1, L = 0;
        while (s <= n + m - 2) s <<= 1, ++L;
        init(L);
        for (int i = 0; i < s; ++i) {
            A[i] = i < n ? Complex(a[i] / M, a[i] % M) : Complex();
            B[i] = i < m ? Complex(b[i] / M, b[i] % M) : Complex();
        }
        trans(A, s, 1); trans(B, s, 1);
        for (int i = 0; i < s; ++i) {
            int j = i ? s - i : i;
            Complex a1 = (A[i] + A[j].conj()) * Complex(0.5, 0);
            Complex a2 = (A[i] - A[j].conj()) * Complex(0, -0.5);
            Complex b1 = (B[i] + B[j].conj()) * Complex(0.5, 0);
            Complex b2 = (B[i] - B[j].conj()) * Complex(0, -0.5);
            Complex c11 = a1 * b1 , c12 = a1 * b2;
            Complex c21 = a2 * b1 , c22 = a2 * b2;
            C1[j] = c11 + c12 * Complex(0, 1);
            C2[j] = c21 + c22 * Complex(0, 1);
        }
        trans(C1, s, -1); trans(C2, s, -1);
        for (int i = 0 ; i < n + m - 1; ++i) {
            int x = int64(C1[i].x + 0.5) % mod;
            int y1 = int64(C1[i].y + 0.5) % mod;
            int y2 = int64(C2[i].x + 0.5) % mod;
            int z = int64(C2[i].y + 0.5) % mod;
            res[i] = ((int64)x * M * M + (int64)(y1 + y2) * M + z) % mod;
        }
    }
}

int n,m;
VI a,b;
int main()
{
#ifdef indiewar
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    int x;
    cin >> n >> m;
    rep(i,0,n+1)
    {
        cin >> x;a.pb(x);
    }
    rep(i,0,m+1)
    {
        cin >> x;b.pb(x);
    }
    vector<ll> res;
    if(a.size() >= 2 && b.size()>=2)
         res = fft::fast_conv(a,b);
    else
         res = fft::conv(a,b);
    for(auto &v:res) cout << v << " ";
    return 0;
}
```

## fwt

-  计算集合卷积

```c_cpp
void fwt(ll *a, int n)
{
    for(int d = 1;d < n;d <<= 1){
        for(int m = d << 1,i = 0;i < n;i += m){
            for(int j = 0;j < d;++j){
                ll x = a[i + j],y = a[i + j + d];
                a[i + j] = (x + y),a[i + j + d] = (x - y);
                //xor:a[i + j] = x + y,a[i + j + d] = (x - y + mod) % mod;
                //and:a[i + j] = x + y;
                //or:a[i + j + d] = x + y;
            }
}
void ufwt(ll *a, int n)
{
    for(int d = 1;d < n;d <<= 1){
        for(int m = d << 1,i = 0;i < n;i += m){
            for(int j = 0;j < d;++j){
                ll x = a[i + j],y = a[i + j + d];
                a[i + j] = 1LL * (x + y) / 2,a[i + j + d] = (1LL * (x - y) / 2);
                //xor:a[i + j] = (x + y) / 2,a[i + j + d] = (x - y) / 2;
                //and:a[i + j] = x - y;
                //or:a[i + j + d] = y - x;
            }
}
void work(ll *a,ll *b, int n)
{
    fwt(a,n);
    fwt(b,n);
    for(int i = 0;i < n;++i) a[i] *= b[i];
    ufwt(a,n);
}
```

## polya

-  m种颜色，n个长度

```c_cpp

const int N = 1e5 + 7;
int euler(int n){
    int ans = n;
    for(int i = 1;i <= cnt && prime[i] * prime[i] <= n;++i)
        if(n % prime[i] == 0){
            ans -= ans / prime[i];
            while(n % prime[i] == 0) n /= prime[i];
        }
    if(n > 1) ans -= ans / n;
    return ans;
}
int n,m;
int main()
{
    getprime();
    while(scanf("%d%d",&m,&n) && (n || m)){
        ll ans = 0;
        for(int i = 1; i * i <= n;++i){
            if(n % i == 0)
                ans += i * i == n ? euler(i) * fpow(m,n / i) : euler(i) * fpow(m,n / i) + euler(n / i) * fpow(m,i);
        }
        ans += n & 1 ? n * fpow(m,n / 2 + 1) : (fpow(m,n >> 1) + fpow(m,n / 2 + 1)) * (n >> 1);
        printf("%lld\n",ans / (n << 1LL));
    }
    return 0;
}
```

## 大素数

- 包含分解，判断过程为$O(n^\frac{1}{4})$

```c_cpp
typedef long long ll;
int pri[] = {2,3,5,7,11,13,17,19,23,29,31};
ll minfacotr;
ll mult(ll a, ll b, ll mod)  // 大数乘法
{
    ll ans = 0;
    while(b)
    {
        if (b&1)
        {
            ans+= a;
            if (ans >= mod)
                ans -= mod;
        }
        b >>= 1;
        a <<= 1;
        if (a >= mod)
            a-= mod;
    }
    return ans;
}
ll qpow(ll x, ll n, ll mod)
{
    ll ans = 1;
    while(n)
    {
        if (n&1)
            ans = mult(ans, x, mod);
        x = mult(x, x, mod);
        n >>= 1;
    }
    return ans;
}
bool wintness(ll n, ll a)
{
    ll p = qpow(a, n-1, n);
    if(p != 1)
        return false;
    ll s = n - 1;
    while(!(s&1)&& p == 1)
    {
        s >>= 1;
        p = qpow(a, s, n);
    }
    if (p == 1 || p == n - 1)
        return true;typedef long long ll;
int pri[] = {2,3,5,7,11,13,17,19,23,29,31};
ll minfacotr;
ll mult(ll a, ll b, ll mod)  // 大数乘法
{
    ll ans = 0;
    while(b)
    {
        if (b&1)
        {
            ans+= a;
            if (ans >= mod)
                ans -= mod;
        }
        b >>= 1;
        a <<= 1;
        if (a >= mod)
            a-= mod;
    }
    return ans;
}
ll qpow(ll x, ll n, ll mod)
{
    ll ans = 1;
    while(n)
    {
        if (n&1)
            ans = mult(ans, x, mod);
        x = mult(x, x, mod);
        n >>= 1;
    }
    return ans;
}
bool wintness(ll n, ll a)
{
    ll p = qpow(a, n-1, n);
    if(p != 1)
        return false;
    ll s = n - 1;
    while(!(s&1)&& p =
    return false;
}
bool miller_rabin(ll n) // 判断素数
{
    if (n < 32)
    {
        for(int i = 0; i < 11; ++i)
            if(n == pri[i])
                return true;
        return false;
    }
    for(int i = 0 ; i < 10; ++i)
        if(!wintness(n,pri[i]))
            return false;
    return true;
}
ll gcd(ll a, ll b)
{
    return b ? gcd(b, a % b) : a;
}
ll pollard_rho(ll n, ll c)  // Pollard_rho 大数分解
{
    ll x= rand() % n, y = x, i = 1, k = 2, d;
    while(1)
    {
        i++;
        x =(mult(x, x, n) + c) % n;
        d = gcd(y-x+n,n);
        if(d > 1 && d < n)
            return d;
        if(y == x)
            return n;
        if (i == k)
        {
            y = x;
            k <<= 1;
        }
    }
}
ll fac[maxn];
int cnt = 0;
void findfactor(ll n)
{
    if(miller_rabin(n))
    {
        minfacotr = min(minfacotr,n);// 求最小素数因子
        fac[++cnt] = n;//储存素数
        return ;
    }
    ll p = n;
    while(p >= n)
        p = pollard_rho(n, rand() % (n - 1) + 1);
    findfactor(p);
    findfactor(n / p);
}
```

## 线性基

```c_cpp
struct L_B{
    ll d[64],p[64];
    int cnt;
    void init(){// 初始化
        memset(d,0,sizeof d);
        memset(p,0,sizeof p); // 单位基
        cnt = 0; // 单位基中1的数量
    }
    bool insert(ll val){ // 插入 如果x的1数位不存在则插入val，存在则赋值为0
        for(int i = 63;i >= 0;--i)
            if(val & (1LL << i)){
                if(!d[i]){
                    d[i] = val;
                    break;
                }
                val ^= d[i];
            }
        return val > 0;
    }
    ll query_max(){ // 查询最大异或和
        ll ret = 0;
        for(int i = 63;i >= 0;--i)
            if((ret ^ d[i]) > ret)
                ret ^= d[i];
        return ret;j >= 0;--j)
                if(d[i] & (1LL << j)) d[i] ^= d[j];
        for(int i = 0;i <= 63;++i)
            if(d[i]) p[cnt++] = d[i];
    }
    ll kth_query(ll k){ // 查询第k小值
        int ret = 0;
        if(k >= (1LL << cnt))
            return -1;
        for(int i = 63;i >= 0;--i)
            if(k & (1LL << i)) ret ^= p[i];
        return ret;
    }
}
L_B merge(const L_B &n1,const L_B &n2) // 暴力合并两个线性基
{
    L_B ret = n1;
    for(int i = 63;i >= 0;--i)
        if(n2.d[i]) ret.insert(n1.d[i]);
    return ret;
}
```

## 洲阁筛

## 计算素数k次幂前缀和

```c_cpp
const int N = 1e6 + 7;
ll n,k,sqrtn;
int m;
ll a[N << 1],cnt;
int pos1[N],pos2[N];
ull g[N << 1]; // 构造函数
int pri[N],pcnt;
bool ispri[N];
void get_pri()
{
   for(int i = 2;i < N;++i){
       if(!ispri[i]) pri[++pcnt] = i;
       for(int j = 1;j <= pcnt && i * pri[j] < N;++j){
          ispri[i * pri[j]] = 1;
          if(i % pri[j] == 0) break;
       }
   }
}

inline int get_pos(ll x)
{
    return x <= sqrtn ? pos1[x] : pos2[n / x];
}
void Discretization(){ // 离散化处理
    for(ll i = 1,j;i <= n;i = j + 1){
        a[++cnt] = n / i;
        j = n / (n / i);
    }
    reverse(a + 1,a + 1 + cnt);
    for(int i = 1;i <= cnt;++i)
        if(a[i] <= sqrtn) pos1[a[i]] = i;
        else pos2[n / a[i]] = i;
}
void calc_g() // 预处理构造函数
{
    for(int i = 1;i <= cnt;++i) g[i] = a[i] - 1;
    for(int i = 1;i <= m;++i)
        for(int j = cnt;j >= 1 && a[j] >= pri[i] * pri[i];--j)
            g[j] -= g[get_pos(a[j] / pri[i])] - g[get_pos(pri[i] - 1)];
}
ull calc_h(ll i,ll j){ // 计算递归函数
    if(i <= 1) return 0;
    ull sum = 0;
    int res;
    for(res = j;res <= m && pri[res] * pri[res] <= i;++res)
        for(ll o = pri[res],e = 1;o <= i;o *= pri[res],++e)
            sum += (ull)(e * k + 1) * (calc_h(i / o,res + 1) + 1);
    if(pri[res - 1] <= i)
        sum += (ull)(k + 1) * (g[get_pos(i)] - g[get_pos(pri[res - 1])]);
    return sum;
}
int t;
int main()
{
    get_pri();
    scanf("%lld%lld",&n,&k);
    sqrtn = (ll)sqrt(n);cnt = 0;
    m = upper_bound(pri + 1,pri + 1 + pcnt,sqrtn) - pri - 1;
    Discretization();
    calc_g();
    ull ans = (ull)(k + 1) * (g[get_pos(n)] - m);
    for(int i = 1;i <= m;++i)
        for(ll j = pri[i],e = 1;j <= n;j *= pri[i],e++)
            ans += (ull)(e * k + 1) * (calc_h(n / j,i + 1) + 1);
    ans++;
    printf("%ull\n",ans);
    return 0;
}
```

## 自然幂数和

```c_cpp
void init()
{
//预处理组合数
    for(int i = 0; i < N;++i){
        C[i][0] = C[i][i] = 1;
        if (i == 0)
            continue;
        for (int j = 1; j < i;++j)
            C[i][j] = (C[i - 1][j] % mod + C[i - 1][j - 1] % mod) % mod;
    }
//预处理逆元
    inv[1] = 1;
    for (int i = 2; i < N; ++i)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
//预处理伯努利数
    B[0] = 1;
    for (int i = 1; i < N; ++i)
    {
        ll ans = 0;
        if (i == N - 1)
            break;
        for (int j = 0; j < i; ++j)
        {
            ans += C[i + 1][j] * B[j];
            ans %= mod;
        }
        ans *= -inv[i + 1];
        ans = (ans % mod + mod) % mod;
        B[i] = ans;
    }
}
ll Work(int k)
{
    ll ans = inv[k + 1];
    ll sum = 0;
    for(int i=1; i<=k+1; ++i)
    {
        sum += C[k + 1][i] * tmp[i] % mod * B[k + 1 - i] % mod;
        sum %= mod;
    }
    ans *= sum;
    ans %= mod;
    return ans;
}
int main()
{
    int t;
    init();
    scanf("%d", &t);
    while(t--)
    {
        int k;
        scanf("%lld %d", &n, &k);
        n %= mod;
        tmp[0] = 1;
        for(int i = 1; i < N; ++i)
            tmp[i] = tmp[i - 1] * (n + 1) % mod;
        printf("%lld\n", Work(k));
    }
    return 0;
}
```

## 组合数打表

```c_cpp
ll f[N],inv[N];
inline ll C(ll a,ll b){return a < 0 || b < 0 || a < b ? 0 : f[a] * inv[b] % mod * inv[a - b] % mod;}
void get_table(int index)
{
    f[0] = inv[0] = 1;
    for(int i = 1;i <= index;++i) f[i] = f[i - 1] * i % mod;
    inv[index] = fpow(f[index],mod - 2);
    for(;index;--index)
        inv[index - 1] = inv[index] * index % mod;
}
```

## 杜教筛

```c_cpp
const int N = 4e6 + 7;
const int mod = 1e9 + 7;
int prime[N],cnt;
ll g[N],phi[N];
bool isprime[N];
ll n,m;
inline ll gao(ll x)
{
    x %= mod;
    return (x + 1) % mod * x % mod * inv2 % mod;
}
void get_phi() // 预处理phi或者Mobius,n^(2/3)的前缀和
{
   phi[1] = 1;
   for(int i = 2;i < N;++i){
       if(!isprime[i]){
             prime[++cnt] = i;
             phi[i] = i - 1;
        }
       for(int j = 1;j <= cnt && i * prime[j] < N;++j)
       {
          isprime[i * prime[j]] = 1;
          if(i % prime[j] == 0){
             phi[i * prime[j]] = phi[i] * prime[j];
             break;
          }
          phi[i * prime[j]] = phi[i] * (prime[j] - 1);
       }
   }
   for(int i = 1;i < N;++i) g[i] = (g[i - 1] + phi[i] * i % mod) % mod;
}

inline ll cal(ll x) //
{
    x %= mod;
    return x * (2 * x + 1) % mod * (x + 1) % mod * inv6 % mod;
}
map<ll ,ll>mp; // 存已到达情况
ll solve(ll pos) // 递归
{
    if(pos < N) return g[pos];
    if(mp[pos]) return mp[pos];
    ll res = cal(pos),last;
    for(ll i = 2;i <= pos;i = last + 1){
        last = pos / (pos / i);
        res = ((res - (gao(last) - gao(i - 1)) * solve(pos / i) % mod) % mod + mod) % mod;
    }
    mp[pos] = res;
    return res;
}
ll work(ll pos)
{
    ll last,ans = 0;
    for(ll i = 1;i <= pos;i = last + 1){
        last = pos / (pos / i);
        ans = (ans + (last - i + 1) % mod * solve(pos / i) % mod) % mod + mod;
        ans %= mod;
    }
    return (ans + pos) % mod * inv2 % mod;
}
int main()
{
    get_phi();
    scanf("%lld%lld",&n,&m);
    printf("%lld\n",((work(m) - work(n - 1)) % mod + mod) % mod);
    return 0;
}
```

## 二次剩余

### 解$x^2=a(mod\:p)$

```c_cpp
struct T{
    ll p, d;
};
ll w;
//二次域乘法
T multi_er(T a, T b, ll m)
{
    T ans;
    ans.p = (a.p * b.p % m + a.d * b.d % m * w % m) % m;
    ans.d = (a.p * b.d % m + a.d * b.p % m) % m;
    return ans;
}
//二次域上快速幂
T power(T a, ll b, ll m)
{
    T ans;
    ans.p = 1;
    ans.d = 0;
    while(b){
        if(b & 1)
        ans = multi_er(ans, a, m);
        b >>= 1;
        a = multi_er(a, a, m);
    }
    return ans;
}
//求勒让德符号
ll Legendre(ll a, ll p)
{
    return qpow(a, (p-1)>>1, p);
}
ll mod(ll a, ll m)
{
    a %= m;
    if(a < 0) a += m;
    return a;
}
ll Solve(ll n,ll p)
{
    if(p == 2) return 1;
    if (Legendre(n, p) + 1 == p)
        return -1;
    ll a = -1, t;
    while(true) {
        a = rand() % p;
}
int main()
{
    int t;
    scanf("%d", &t);
    while(t--){
        int n, p;
        scanf("%d %d",&n,&p);
        n %= p;
        int a = Solve(n, p);//x * x = n % p
        if(a == -1) {
            puts("No root");
            continue;
        }
        int b = p - a;
        if(a > b) swap(a, b);
        if(a == b)
            printf("%d\n",a);
        else printf("%d %d\n",a,b);
    }
    return 0;
}
```

## 高精度

```c_cpp
struct BigInteger {
    typedef unsigned long long ll;

    static const int BASE = 100000000;
    static const int WIDTH = 8;
    vector<int> s;

    BigInteger& clean(){while(!s.back()&&s.size()>1)s.pop_back(); return *this;}
    BigInteger(ll num = 0) {*this = num;}
    BigInteger(string s) {*this = s;}
    BigInteger& operator = (long long num) {
        s.clear();
        do {
            s.push_back(num % BASE);
            num /= BASE;
        } while (num > 0);
        return *this;
    }
    BigInteger& operator = (const string& str) {
        s.clear();
        int x, len = (str.length() - 1) / WIDTH + 1;
        for (int i = 0; i < len; i++) {
            int end = str.length() - i*WIDTH;
            int start = max(0, end - WIDTH);
            sscanf(str.substr(start,end-start).c_str(), "%d", &x);
            s.push_back(x);
        }
        return (*this).clean();
    }

    BigInteger operator + (const BigInteger& b) const {
        BigInteger c; c.s.clear();
        for (int i = 0, g = 0; ; i++) {
            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = g;
            if (i < s.size()) x += s[i];
            if (i < b.s.size()) x += b.s[i];
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c;
    }
    BigInteger operator - (const BigInteger& b) const {
        assert(b <= *this); // 减数不能大于被减数
        BigInteger c; c.s.clear();
        for (int i = 0, g = 0; ; i++) {
            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = s[i] + g;
            if (i < b.s.size()) x -= b.s[i];
            if (x < 0) {g = -1; x += BASE;} else g = 0;
            c.s.push_back(x);
        }
        return c.clean();
    }
    BigInteger operator * (const BigInteger& b) const {
        int i, j; ll g;
        vector<ll> v(s.size()+b.s.size(), 0);
        BigInteger c; c.s.clear();
        for(i=0;i<s.size();i++) for(j=0;j<b.s.size();j++) v[i+j]+=ll(s[i])*b.s[j];
        for (i = 0, g = 0; ; i++) {
            if (g ==0 && i >= v.size()) break;
            ll x = v[i] + g;
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c.clean();
    }
    BigInteger operator / (const BigInteger& b) const {
        assert(b > 0);  // 除数必须大于0
        BigInteger c = *this;       // 商:主要是让c.s和(*this).s的vector一样大
        BigInteger m;               // 余数:初始化为0
        for (int i = s.size()-1; i >= 0; i--) {
            m = m*BASE + s[i];
            c.s[i] = bsearch(b, m);
            m -= b*c.s[i];
        }
        return c.clean();
    }
    BigInteger operator % (const BigInteger& b) const { //方法与除法相同
        BigInteger c = *this;
        BigInteger m;
        for (int i = s.size()-1; i >= 0; i--) {
            m = m*BASE + s[i];
            c.s[i] = bsearch(b, m);
            m -= b*c.s[i];
        }
        return m;
    }

    int bsearch(const BigInteger& b, const BigInteger& m) const{
        int L = 0, R = BASE-1, x;
        while (1) {
            x = (L+R)>>1;
            if (b*x<=m) {if (b*(x+1)>m) return x; else L = x;}
            else R = x;
        }
    }
    BigInteger& operator += (const BigInteger& b) {*this = *this + b; return *this;}
    BigInteger& operator -= (const BigInteger& b) {*this = *this - b; return *this;}
    BigInteger& operator *= (const BigInteger& b) {*this = *this * b; return *this;}
    BigInteger& operator /= (const BigInteger& b) {*this = *this / b; return *this;}
    BigInteger& operator %= (const BigInteger& b) {*this = *this % b; return *this;}

    bool operator < (const BigInteger& b) const {
        if (s.size() != b.s.size()) return s.size() < b.s.size();
        for (int i = s.size()-1; i >= 0; i--)
            if (s[i] != b.s[i]) return s[i] < b.s[i];
        return false;
    }
    bool operator >(const BigInteger& b) const{return b < *this;}
    bool operator<=(const BigInteger& b) const{return !(b < *this);}
    bool operator>=(const BigInteger& b) const{return !(*this < b);}
    bool operator!=(const BigInteger& b) const{return b < *this || *this < b;}
    bool operator==(const BigInteger& b) const{return !(b < *this) && !(b > *this);}
};

ostream& operator << (ostream& out, const BigInteger& x) {
    out << x.s.back();
    for (int i = x.s.size()-2; i >= 0; i--) {
        char buf[20];
        sprintf(buf, "%08d", x.s[i]);
        for (int j = 0; j < strlen(buf); j++) out << buf[j];
    }
    return out;
}

istream& operator >> (istream& in, BigInteger& x) {
    string s;
    if (!(in >> s)) return in;
    x = s;
    return in;
}
```

## 反素数

### 求小于 n 并且因子个数最多的那个数
```cpp
int pri[]= {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61};
ll n, ans, tmp;
const ll INF = 0x3f3f3f3f;
void dfs(int step, ll sum, ll num) //num 为因子个数
{
    if(step == 16) return;
    if(num > tmp){
        ans = sum;
        tmp = num;
    }
    if(sum > n) return ;

    if(num == tmp && sum < ans)//因子个数一样,选取较小的那个数
        ans = sum;
    for(int i = 1; i <= 63; ++i){
        if(n / pri[step] < sum) break;
        dfs(step + 1, sum *= pri[step], num * (i + 1));
    }
}

//求一个最小的正整数,使得它的因子个数为 n
int p[16] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
void dfs(int dept,ull tmp,int num)
{
    if(num > n) return;
    if(num == n && ans > tmp)
        ans = tmp;
    for(int i=1; i <= 63;++i){
        if(ans / p[dept] < tmp)
            break;
        dfs(dept+1,tmp *= p[dept],num * (i + 1));
    }
}
```
## 求区间[1,N]的质数的个数(1≤N≤10^11)
```cpp
ll f[340000],g[340000],n;  
    void init(){  
        ll i,j,m;  
        for(m=1;m*m<=n;++m)f[m]=n/m-1;  
        for(i=1;i<=m;++i)g[i]=i-1;  
        for(i=2;i<=m;++i){  
            if(g[i]==g[i-1])continue;  
            for(j=1;j<=min(m-1,n/i/i);++j){  
                if(i*j<m)f[j]-=f[i*j]-g[i-1];  
                else f[j]-=g[n/i/j]-g[i-1];  
            }  
            for(j=m;j>=i*i;--j)g[j]-=g[j/i]-g[i-1];  
        }  
    }  
    int main(){  
        while(scanf("%I64d",&n)!=EOF){  
            init();  
            cout<<f[1]<<endl;  
        }  
        return 0;  
    }
```
O(n^(2/3))
``` cpp
const int N = 5e6 + 2;  
bool np[N];  
int prime[N], pi[N];  
int getprime()  
{  
    int cnt = 0;  
    np[0] = np[1] = true;  
    pi[0] = pi[1] = 0;  
    for(int i = 2; i < N; ++i)  
    {  
        if(!np[i]) prime[++cnt] = i;  
        pi[i] = cnt;  
        for(int j = 1; j <= cnt && i * prime[j] < N; ++j)  
        {  
            np[i * prime[j]] = true;  
            if(i % prime[j] == 0)   break;  
        }  
    }  
    return cnt;  
}  
const int M = 7;  
const int PM = 2 * 3 * 5 * 7 * 11 * 13 * 17;  
int phi[PM + 1][M + 1], sz[M + 1];  
void init()  
{  
    getprime();  
    sz[0] = 1;  
    for(int i = 0; i <= PM; ++i)  phi[i][0] = i;  
    for(int i = 1; i <= M; ++i)  
    {  
        sz[i] = prime[i] * sz[i - 1];  
        for(int j = 1; j <= PM; ++j) phi[j][i] = phi[j][i - 1] - phi[j / prime[i]][i - 1];  
    }  
}  
int sqrt2(LL x)  
{  
    LL r = (LL)sqrt(x - 0.1);  
    while(r * r <= x)   ++r;  
    return int(r - 1);  
}  
int sqrt3(LL x)  
{  
    LL r = (LL)cbrt(x - 0.1);  
    while(r * r * r <= x)   ++r;  
    return int(r - 1);  
}  
LL getphi(LL x, int s)  
{  
    if(s == 0)  return x;  
    if(s <= M)  return phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];  
    if(x <= prime[s]*prime[s])   return pi[x] - s + 1;  
    if(x <= prime[s]*prime[s]*prime[s] && x < N)  
    {  
        int s2x = pi[sqrt2(x)];  
        LL ans = pi[x] - (s2x + s - 2) * (s2x - s + 1) / 2;  
        for(int i = s + 1; i <= s2x; ++i) ans += pi[x / prime[i]];  
        return ans;  
    }  
    return getphi(x, s - 1) - getphi(x / prime[s], s - 1);  
}  
LL getpi(LL x)  
{  
    if(x < N)   return pi[x];  
    LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1;  
    for(int i = pi[sqrt3(x)] + 1, ed = pi[sqrt2(x)]; i <= ed; ++i) ans -= getpi(x / prime[i]) - i + 1;  
    return ans;  
}  
LL lehmer_pi(LL x)  
{  
    if(x < N)   return pi[x];  
    int a = (int)lehmer_pi(sqrt2(sqrt2(x)));  
    int b = (int)lehmer_pi(sqrt2(x));  
    int c = (int)lehmer_pi(sqrt3(x));  
    LL sum = getphi(x, a) +(LL)(b + a - 2) * (b - a + 1) / 2;  
    for (int i = a + 1; i <= b; i++)  
    {  
        LL w = x / prime[i];  
        sum -= lehmer_pi(w);  
        if (i > c) continue;  
        LL lim = lehmer_pi(sqrt2(w));  
        for (int j = i; j <= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - 1);  
    }  
    return sum;  
}  
int main()  
{  
    init();  
    LL n;  
    while(~scanf("%lld",&n))  
    {  
        printf("%lld\n",lehmer_pi(n));  
    }  
    return 0;  
}
```
## 高斯消元
```cpp
const int N = 307;
int x[N],a[N][N];// x[N]解集，a[N][N]系数
bool free_x[N];
int gcd(int a,int b){return b ? gcd(b,a % b) : a;}
int lcm(int a,int b){return a / gcd(b,a % b) * b;}
int Gauss(int equ,int var)//equ个方程，var个变元
{
    int free_x_num,i,j,row,max_r,col;//row表示行,col表示列,max_r表示列最大的行,free_x_num变元数量
    int free_index,LCM,ta,tb,temp;// free_index变元下标
    for(i = 0;i <= var;++i){
        x[i] = 0;
        free_x[i] = true;//第i个元素是否是变元
    }
    for(row = 0,col = 0;row < equ && col < var;++row,++col){
        max_r = row;
        //找到col最大的行，进行交换（除法时减小误差）
        for(i = row + 1;i < equ;++i) if(abs(a[i][col]) > abs(a[max_r][col])) max_r = i;
        //与第row行交换
        if(max_r != row) for(j = row;j < var + 1;++j) swap(a[row][j],a[max_r][j]);
        if(a[row][col]==0){
            //说明该col列第row行以下全是0了，则处理当前行的下一列.
            row--;
            continue;
        }
        for(i = row + 1;i < equ;++i)//枚举被删行
            if(a[i][col]){
                LCM = lcm(abs(a[i][col]),abs(a[row][col]));
                ta = LCM / abs(a[i][col]);
                tb = LCM / abs(a[row][col]);
                if(a[i][col] * a[row][col] < 0)tb = -tb;//异号的情况是相加
                for(j = col;j < var + 1;++j)
                    a[i][j] = a[i][j] * ta - a[row][j] * tb;
            }
        /*求解小数解,防止溢出
        for(int i = row + 1; i < equ; ++i)
            if(fabs(a[i][col]) > eps){
                double t1 = a[i][col]/a[row][col];
                for(int j = col; j <= var;++j) a[i][j] -= a[row][j] * t1;
            }*/
    }
    for (i = row;i < equ;++i) if(a[i][col]) return -1; // 无解
    if (row < var){// 多解
        for(i = row - 1;i >= 0;--i){
            free_x_num = 0;
            for (j = 0;j < var;++j)
                if(a[i][j] && free_x[j]) free_x_num++,free_index = j;
            if (free_x_num > 1) continue; // 无法求解出确定的变元.
            temp = a[i][var];
            for (j = 0;j < var;++j) if (a[i][j] && j != free_index) temp -= a[i][j] * x[j];
            x[free_index] = temp / a[i][free_index]; //求出该变元.
            free_x[free_index] = 0; //该变元是确定的.
        }
        return var - row; //自由变元有 var - row 个.
    }
    for (i = var - 1; i >= 0;--i){// 唯一解
        temp = a[i][var];
        for (j = i + 1;j < var;++j)
            if (a[i][j]) temp -= a[i][j] * x[j];
        if (temp % a[i][i]) return -2; // 说明有浮点数解,但无整数解.
        x[i] = temp / a[i][i];
    }
    return 0;
}
```

## 高斯消元解异或方程

```c_cpp
int Guass_xor(int equ,int var)
{
    int row,col;
    for(row = 0, col = 0; row < equ && col < var; ++row, ++col){
        int maxr = row;
        for(int i = row; i < equ; ++i)
            if(a[i][col] > a[maxr][col]) maxr = i;
            if(maxr != row) for(int j = col; j <= var; ++j) swap(a[maxr][j],a[row][j]);
            if(!a[row][col]){
                row--;
                continue;
            }
            for(int i = row + 1; i < equ; ++i)
                if(a[i][col])
                    for(int j = col; j <= var; ++j) a[i][j] ^= a[row][j];
    }
    for(int i = row; i < equ; ++i) if(a[i][col]) return -1;//无可行解
    if(row < var) // 存在多解
            for(int i = row - 1; i >= 0; --i){
                int num = 0, index;
                for(int j = 0; j < var; ++j)
                    if(a[i][j]  && vis[j]) num++, index = j;
                if(num > 1) continue;
                for(int j = 0; j < var; ++j)
                    if(j != index) x[index] ^= (a[i][j] && x[j]);
                vis[index] = false;
            }
    for(int i = var - 1; i >= 0; --i){ //唯一解
        x[i] = a[i][var];
        for(int j = i + 1; j < var; ++j) x[i] ^=(a[i][j] && x[j]);
    }
    return 0;
}
```

## 矩阵类（快速幂）

```c_cpp
int sz;
struct Matrix{
    ll a[10][10];
    Matrix(){
        for(int i = 0;i < sz;++i)
            for(int j = 0;j < sz;++j)
                if(i == j) a[i][j] = 1;
                else a[i][j] = 0;
    }
    void init(){
        memset(a,0,sizeof a);
    }
    void show(){
        for(int i = 0;i < sz;++i)
            for(int j = 0;j < sz;++j)
                dd(i),dd(j),de(a[i][j]);
    }
    void Relation_matrix(ll *s){
        init();
        for(int i = 0;i < sz;++i){
            if(i + 1 < sz) a[i][i + 1] = 1;
            a[sz - 1][i] = s[i];
        }
    }
    Matrix operator *(const Matrix& tmp) const{
        Matrix res;
        res.init();
        for(int i = 0;i < sz;++i)
            for(int j = 0;j < sz;++j)
                for(int k = 0;k < sz;++k)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * tmp.a[k][j] % mod) % mod;
        return res;
    }
    Matrix operator +(Matrix tmp){
        for(int i = 0;i < sz;++i)
            for(int j = 0;j < sz;++j)
                a[i][j] += tmp.a[i][j];
    }
    friend Matrix fpow(Matrix a,ll b){
        Matrix res;
        while(b){
            if(b & 1) res = res * a;
            a = a * a;
            b >>= 1;
        }
        return res;
    }
    ll get_fib(){
        Matrix tmp;
        tmp.init();
        for(int i = 0;i < sz;++i)
            tmp.a[i][0] = 1;
        Matrix ans = *this;
        ans = ans * tmp;
        return ans.a[0][0];
    }
};
```

## 类欧几里得
- 求解$f(a,b,c,n) = \sum^{n}_{i=0} \lfloor \frac{a*i+b}{c} \rfloor$

```c_cpp
ll f(ll a,ll b,ll c,ll n)
{
    if(a == 0)
        return (b / c) * (n + 1) % mod;
    if(a >= c)
        return (n * (n + 1) / 2 % mod * (a / c) % mod + f(a % c,b,c,n)) % mod;
    if(b >= c)
        return ((b / c) * (n + 1) % mod + f(a,b % c,c,n)) % mod;
    //ll m = (a * n + b) / c % mod;
    ll m = (n / c * a + (n % c * a + b) / c);
    return ((m % mod) * (n % mod) % mod - f(c,c - b - 1,a,m - 1) + mod) % mod;
}

```

## 牛顿迭代

```c_cpp
#define f(x) () //原函数
#define f2(x) () //导函数
double Newton(double x){
    for(int i = 0;i < 100;++i){
        x = x - f(x) / f2(x); //牛顿迭代法
        if(fabs(f(x)) < eps) return x;
    }
    return -1;
}

```

## 母函数

- n 个人分成任意组,每组人数必须为素数,有多少种分法,n < 150;

```c_cpp
void solve()
{
    memset(a, 0, sizeof a);
    for(int i = 0; i <= 160; i += 2)
        a[i] = 1;
    memset(b, 0, sizeof b);
    for(int i = 1; pri[i] <= 150;++i){
        for(int j = 0; j <= 150;++j)
            for(int k = 0;k + j <= 150;k += pri[i])
                b[k + j] += a[j];
        for(int j = 0; j <= 150; ++j){
            a[j] = b[j];
            b[j] = 0;
        }
    }
}
```

## 莫比乌斯反演

- 求有多少个数对 (x,y) ,满足 a ≤ x ≤ b , c ≤ y ≤ d ,且 gcd(x,y) = 1

```c_cpp
void Mobius()
{
    cnt = 0;
    mu[1] = 1;sum[1] = 1;
    for(int i = 2; i < maxn; ++i){
        if(!vis[i]){
            prime[++cnt] = i;
            mu[i] = -1;
        }
        for(int j = 1; j <= cnt; ++j){
            if(i * prime[j] >= maxn) break;
            vis[i * prime[j]] = true;
            if(i % prime[j]== 0){
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
        sum[i] = sum[i-1] + mu[i];
    }
}
ll solve(int b, int d)
{
    if(b > d) swap(b, d);
    ll ans = 0,pos;
    for(int i = 1; i <= b; i = pos+1){
        pos = min(b / (b / i),d / (d / i));
        ans += 1LL * (b / i) * (d / i) * (sum[pos] - sum[i - 1]);
    }
    return ans;
}
```

## 斐波那契广义循环节

- $f(n)=af(n-1)+bf(n-2)\:\:\: f(1)=c \:\:\:f(2)=d$

```c_cpp
const int N = 2;
const ll mod = 1000000007;

ll fac[2][505];
int cnt,ct;

ll pri[6] = {2, 3, 7, 109, 167, 500000003};
ll num[6] = {4, 2, 1, 2, 1, 1};

struct Matrix
{
    ll m[N][N];
} ;

Matrix A;
Matrix I = {1, 0, 0, 1};

Matrix multi(Matrix a,Matrix b)
{
    Matrix c;
    for(int i=0; i<N; i++)
    {
        for(int j=0; j<N; j++)
        {
            c.m[i][j]  =0;
            for(int k=0; k<N; k++)
            {
                c.m[i][j] += a.m[i][k] * b.m[k][j];
                c.m[i][j] %= mod;
            }
        }
    }
    return c;
}

Matrix power(Matrix A,ll n)
{
    Matrix ans = I, p = A;
    while(n)
    {
        if(n & 1)
        {
            ans = multi(ans,p);
            n--;
        }
        n >>= 1;
        p = multi(p,p);
    }
    return ans;
}

ll quick_mod(ll a,ll b)
{
    ll ans = 1;
    a %= mod;
    while(b)
    {
        if(b & 1)
        {
            ans = ans * a % mod;
            b--;
        }
        b >>= 1;
        a = a * a % mod;
    }
    return ans;
}

ll Legendre(ll a,ll p)
{
    ll t = quick_mod(a,(p-1)>>1);
    if(t == 1) return 1;
    return -1;
}

void dfs(int dept,ll product = 1)
{
    if(dept == cnt)
    {
        fac[1][ct++] = product;
        return;
    }
    for(int i=0; i<=num[dept]; i++)
    {
        dfs(dept+1,product);
        product *= pri[dept];
    }
}

bool OK(Matrix A,ll n)
{
    Matrix ans = power(A,n);
    return ans.m[0][0] == 1 && ans.m[0][1] == 0 &&
           ans.m[1][0] == 0 && ans.m[1][1] == 1;
}

int main()
{
    fac[0][0] = 1;
    fac[0][1] = 2;
    fac[0][2] = 500000003;
    fac[0][3] = 1000000006;
    ll a,b,c,d;
    while(cin>>a>>b>>c>>d)
    {
        ll t = a * a + 4 * b;
        A.m[0][0] = a;
        A.m[0][1] = b;
        A.m[1][0] = 1;
        A.m[1][1] = 0;
        if(Legendre(t,mod) == 1)
        {
            for(int i=0; i<4; i++)
            {
                if(OK(A,fac[0][i]))
                {
                    cout<<fac[0][i]<<endl;
                    break;
                }
            }
        }
        else
        {
            ct = 0;
            cnt = 6;
            dfs(0,1);
            sort(fac[1],fac[1]+ct);
            for(int i=0;i<ct;i++)
            {
                if(OK(A,fac[1][i]))
                {
                    cout<<fac[1][i]<<endl;
                    break;
                }
            }
        }
    }
    return 0;
}

```

## robenius-equations
use by indiewar
```cpp
//sum_{i=1}^{n} a[i] * x[i] = b, x[i] >= 0
//given a[i] and b, check solution existing
typedef std::pair<LL, int> PLI;
int get_vals(int n, int a[]) {
  std::priority_queue<PLI, std::vector<PLI>, std::greater<PLI>> Q;
  int X = *std::min_element(a, a + n);
  std::fill(dis, dis + X, inf);
  dis[0] = 0; Q.push(PLI(0, 0));
  while (!Q.empty()) {
    PLI nw = Q.top(); Q.pop();
    int u = nw.second;
    LL val = nw.first;
    if (dis[u] != val) continue;
    for (int i = 0; i < n; ++ i) {
      LL tmp = val + a[i];
      int v = tmp % X;
      if (dis[v] > tmp) {
        dis[v] = tmp;
        Q.push(PLI(tmp, v));
      }
    }
  }
  return X;
}
bool ok(int n, int a[], int b) {
  int X = get_vals(n, a);
  return dis[b % X] <= b;
}
```
## logarithm
```cpp
// 求离散对数，即 a^x % m = r的最小非负整数解x，返回-1说明无解
int64 log(int64 a, int64 r, int64 m){
  if (r >= m) return -1;
  int64 i, g, x, c = 0, at = int(2 + sqrt(m));
  for (i = 0, x = 1 % m; i < 50; ++i) {
    if (x == r) return i;
    x = int64(x) * a % m;
  }
  for (g = x = 1; gcd(int64(x) * a % m, m) != g; ++c) {
    x = x * a % m;
    g = gcd(x, m);
  }
  if (r % g) return -1;
  if (x == r) return c;
  std::unordered_map<int64, int64> u;
  g = euler_phi(m / g), u[x] = 0;
  g = pow_mod(a, g - at % g, m);
  for (i = 1; i < at; ++i){ // Baby Step
    x = x * a % m;
    u.emplace(x, i);
    if (x == r) return c + i;
  }
  for (i = 1; i < at; ++i) { // Giant Step
    r = r * g % m;
    auto t = u.find(r);
    if (t != u.end()) return c + i * at + t->second;
  }
  return -1;
}
```

## 拉格朗日插值
```cpp
const int N = 3010, P = 998244353;

int n;
int po[N], pr[N];

int norm(int x) { return x >= P ? x - P : x; }

void exGcd(int a, int b, int& x, int& y) {
    if (!b) {
        x = 1;
        y = 0;
        return;
    }
    exGcd(b, a % b, y, x);
    y -= a / b * x;
}

int inv(int a) {
    int x, y;
    exGcd(a, P, x, y);
    return norm(x + P);
}

int eval(int a[], int n, int x) {
    int ret = 0;
    for (int i = n; i >= 0; --i) ret = (ret * (ll)x + a[i]) % P;
    return ret;
}

int main() {
    int s,n, k, x, y;
    scanf("%d%d%d%d", &s, &k, &x, &y);
    x %= P;
    n = 1;
    po[0] = y;
    pr[1] = 1;
    pr[0] = norm(P - x);
    rep(_,0,s-1)
    {
        scanf("%d%d",&x,&y);
        int v = (y + P - eval(po, n - 1, x)) * (ll)inv(eval(pr, n, x)) % P;
        for (int i = 0; i <= n; ++i) po[i] = (po[i] + pr[i] * (ll)v) % P;
        for (int i = ++n; i; --i) pr[i] = (pr[i - 1] + pr[i] * (ll)(P - x)) % P;
        pr[0] = pr[0] * (ll)(P - x) % P;
    }
    printf("%d\n", eval(po, n - 1, k));
    return 0;
}
```
- 给f(0),f(1)...f(n),求f(m),f(m+1)...,f(m+n)
```cpp
ll pow_mod(ll x, int k) {
    ll ans = 1;
    while (k) {
        if (k & 1)
            ans = ans * x % MOD;
        x = x * x % MOD;
        k >>= 1;
    }
    return ans;
}

ll facd[200005], facv[200005];
ll upd[200005], upv[200005];

void pre(int n, int m) {
    facd[0] = upd[0] = 1;
    for (int i = 1; i <= n; i++) {
        facd[i] = facd[i - 1] * i % MOD;
        upd[i] = upd[i - 1] * (m + i) % MOD;
    }
    facv[n] = pow_mod(facd[n], MOD - 2);
    upv[n] = pow_mod(upd[n], MOD - 2);
    for (int i = n - 1; i >= 0; i--) {
        facv[i] = facv[i + 1] * (i + 1) % MOD;
        upv[i] = upv[i + 1] * (m + i + 1) % MOD;
    }
}

const int Maxn = 1 << 19;

ll *w[19];

void ntt_init() {
    for (int i = 2, t = 0; i <= Maxn; i <<= 1, t++) {
        w[t] = new ll[i >> 1];
        ll wn = pow_mod(3, (MOD - 1) / i);
        w[t][0] = 1;
        for (int j = 1; j < (i >> 1); j++) w[t][j] = w[t][j - 1] * wn % MOD;
    }
}

void rev(ll *p, int len) {
    int j = len >> 1;
    for (int i = 1; i < len - 1; i++) {
        if (i < j)
            swap(p[i], p[j]);
        int k = len >> 1;
        while (j >= k) {
            j -= k;
            k >>= 1;
        }
        if (j < k)
            j += k;
    }
}

void ntt(ll *p, int len, int check) {
    rev(p, len);
    for (int i = 2, t = 0; i <= len; i <<= 1, t++)
        for (int j = 0; j < len; j += i)
            for (int k = j; k < j + (i >> 1); k++) {
                ll u = p[k];
                ll v = w[t][k - j] * p[k + (i >> 1)];
                p[k] = (u + v) % MOD;
                p[k + (i >> 1)] = (u - v) % MOD;
            }
    if (check == -1) {
        reverse(p + 1, p + len);
        ll nev = pow_mod(len, MOD - 2);
        for (int i = 0; i < len; i++) p[i] = (p[i] + MOD) * nev % MOD;
    }
}

int num[100005];
ll p[Maxn], q[Maxn];

int main() {
    ntt_init();
    int n, m;
    scanf("%d%d", &n, &m);
    pre(n << 1, m - n);
    for (int i = 0; i <= n; i++) scanf("%d", &num[i]);
    int len = 1;
    while (len < ((n + 1) << 1)) len <<= 1;
    for (int i = 0; i <= n; i++) {
        p[i] = num[i] * facv[i] % MOD;
        q[i] = ((i & 1) ? MOD - 1 : 1) * facv[i] % MOD;
    }
    for (int i = n + 1; i < len; i++) p[i] = q[i] = 0;
    ntt(p, len, 1);
    ntt(q, len, 1);
    for (int i = 0; i < len; i++) p[i] = p[i] * q[i] % MOD;
    ntt(p, len, -1);
    len <<= 1;
    for (int i = n + 1; i < len; i++) p[i] = 0;
    for (int i = 0; i <= (n << 1); i++) q[i] = upv[i];
    for (int i = (n << 1) + 1; i < len; i++) q[i] = 0;
    ntt(p, len, 1);
    ntt(q, len, 1);
    for (int i = 0; i < len; i++) p[i] = p[i] * q[i] % MOD;
    ntt(p, len, -1);
    for (int i = 0; i <= n; i++) printf("%lld ", p[n + i] * upd[n + i] % MOD);
    printf("\n");
    return 0;
}
```
## Cantor_expansion
```cpp
int n, m, c[1000005], a[1000005], ans = 1;
#define lowbit(x) x & -x
void add(int x, int v) {
    for (; x <= n; x += lowbit(x)) c[x] += v;
}
int sum(int x) {
    int ans = 0;
    for (; x; x -= lowbit(x)) ans += c[x];
    return ans;
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = n, fac = 1; i >= 1; i--, fac = 1ll * fac * (n - i) % mod) {
        ans = (ans + 1ll * sum(a[i] - 1) * fac % mod) % mod;
        add(a[i], 1);
    }
    cout << ans << endl;
}
```
## 无名小定理

 • 1.设$x = gcd(\sum_{i=1}^{n−1}C(n,i))$

 • 当 n 是素数是 x = n  (根据1.)

 • 当 n 有多个素因子 x = 1(根据1.)

 • n 只有一个素因子，答案为该素因子(根据1.)

 • 当 a > b , gcd(a,b) = 1, 那么$ gcd(a^m − b^m, a^n − b^n) = a^{gcd(m,n)} − b^{gcd(n,m)}$

 • $(n+1)*lcm(\sum_{i = 0}^{n}C(n,i)) = lcm(\sum_{i = 1}^{n + 1}i)$

 • 判断组合数 C(n,m)的奇偶性, 当 n & m == m为奇数,反之就是偶数.

 • 三角形求圆半径: 边长为 a, b, c 的三角形面积为 S, 则外接圆半径为$a*b*c/(4S)$, 内切圆半径为 $2 S / (a + b + c)$

 

## 自然常数

e= 2.7182818284590452353602874713526624

## 欧拉常数

C = 0.57721566490153286060651209

## 错排公式

  $D_1 = 0\\ D_2 = 1\\D_n = (n-1)(D_{n-1} + D_{n-2})$

## 伯努利数

 $ F_0 = 1, F_n = _{i=0}^{n-1}C(n,i)F_i$

## 自然幂数和

$\sum_{i = 1}^{n}i^k=\frac{1}{k + 1}\sum_{i = 1}^{k + 1}C(k + 1,i)*F_{k+1-i}*(n+1)^i$

## Catalan

1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012... 

$h(n)=h(n-1)×(4×n2)/(n+1) h(n)=C(2n,n)/(n+1) (n=0,1,2,...)$ 

$h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,...) $

- 将 n + 2 边形沿弦切割成 n 个三角形的不同切割数 
- n + 1 个数相乘, 给每两个元素 加上括号的不同方法数 
- n个节点的不同形状的二叉树数 
- 从 n * n 方格的左上角 移动到右下角不升路径数

## pick 定理

计算点阵中顶点在格点上的多边形面积公式,该公式可以表示为 : $2 * S = 2 * a + b - 2$ , 其中 a 表示多边形内部的点数,b 表示多边形边界上的点数,S 表示多边形的面积.

## 正多边形外接圆半径

$R = \frac{a} {2 sin(\frac {pi} {n} )}$

## Fibonacci

• $-F(n + m) = F(n+1) F(m) + F(n) F(m-1)$ 

• $F(n)^2 = (-1)^{n+1} + F(n-1) F(n+1)$

• 前 n 项有$\lceil \frac{2n} 3 \rceil$个奇数项

• 如果 fib(k)能被 x 整除，则 fib(k*i)都可以被 x 整除。

• $ f(0)+f(1)+f(2)+…+f(n)=f(n+2)-1$

• $f(1)+f(3)+f(5)+…+f(2n-1)=f(2n)$

• $f(2)+f(4)+f(6)+…+f(2n) =f(2n+1)-1$ 

• $[f(0)]^2 + [f(1)]^2 +…+[f(n)]^2=f(n)* f(n+1)$ 

• $f(0)-f(1)+f(2)-…+(-1)^n$

• $f(n)=(-1)^n*[f(n+1)-f(n)]+1$ 

• $f(n+m)=f(n+1)*f(m)+f(n)*f(m-1)$ 

• $[f(n)]^2 =(-1)^{n-1}+f(n-1)*f(n+1) * f(2n-1)=[f(n)]^2 -[f(n-2)]^2$ 

• $3f(n)=f(n+2)+f(n-2)$ 

• $f(2n-2m-2)[f(2n)+f(2n+2)]=f(2m+2)+f(4n-2m) [ n>m>=-1,且 n>=1] $

• $Fn = \frac 1 {\sqrt{5}}*(\frac {1+\sqrt{5}} 2 ) - \frac 1 {\sqrt{5}} ∗ (\frac {1−\sqrt{5}} 2 )$

